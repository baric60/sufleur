import { Branded, Mixed, Type } from 'io-ts';
import { Ord } from 'fp-ts/lib/Ord';
import { Either } from 'fp-ts/lib/Either';
export declare const reportIfFailed: <A>(validation: Either<import("io-ts").Errors, A>) => Either<Error, A>;
export interface Codec<A> extends Type<A, unknown> {
}
export interface IntegerBrand {
    readonly Integer: unique symbol;
}
export declare type Integer = Branded<number, IntegerBrand>;
export declare const integer: Codec<Integer>;
export interface NonNegativeBrand {
    readonly NonNegative: unique symbol;
}
export declare type NonNegative = Branded<number, NonNegativeBrand>;
export declare const nonNegative: Codec<NonNegative>;
export interface PositiveBrand {
    readonly Positive: unique symbol;
}
export declare type Positive = Branded<number, PositiveBrand>;
export declare const positive: Codec<Positive>;
export declare type Natural = NonNegative & Integer;
export declare const natural: Codec<Natural>;
export interface NonEmptySetBrand {
    readonly NonEmptySet: unique symbol;
}
export declare type NonEmptySet<A> = Branded<Set<A>, NonEmptySetBrand>;
export declare const nonEmptySetFromArray: <C extends Mixed>(codec: C, ord: Ord<C["_A"]>) => Type<Branded<Set<C["_A"]>, NonEmptySetBrand>, C["_O"][], unknown>;
export declare type JSONPrimitive = string | number | boolean | null;
export declare const JSONPrimitiveCodec: Codec<JSONPrimitive>;
export interface FractionBrand {
    readonly Fraction: unique symbol;
}
export declare type Fraction = Branded<number, FractionBrand>;
export declare const fraction: import("io-ts").BrandC<import("io-ts").NumberC, FractionBrand>;
export declare const fractionFromPercentage: (a: Branded<number, PercentageBrand>) => Either<Error, Branded<number, FractionBrand>>;
export interface PercentageBrand {
    readonly Percentage: unique symbol;
}
export declare type Percentage = Branded<number, PercentageBrand>;
export declare const percentage: import("io-ts").BrandC<import("io-ts").NumberC, PercentageBrand>;
export declare const percentageFromFraction: (a: Branded<number, FractionBrand>) => Either<Error, Branded<number, PercentageBrand>>;
export declare const mapper: <A extends string | number | boolean, O extends string | number | boolean>(decoded: A, encoded: O, name?: string) => Type<A, O, unknown>;
