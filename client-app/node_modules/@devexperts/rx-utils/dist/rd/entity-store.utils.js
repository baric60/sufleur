"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var observable_map_utils_1 = require("../observable-map.utils");
var rxjs_1 = require("rxjs");
var remote_data_ts_1 = require("@devexperts/remote-data-ts");
var Array_1 = require("fp-ts/lib/Array");
var object_1 = require("@devexperts/utils/dist/object/object");
var operators_1 = require("rxjs/operators");
var tapRD_1 = require("./operators/tapRD");
var mapRD_1 = require("./operators/mapRD");
var switchMapRD_1 = require("./operators/switchMapRD");
var EntityStore = /** @class */ (function () {
    function EntityStore() {
        var _this = this;
        this.cache = new observable_map_utils_1.ObservableMap();
        this.cachedStreams = new Map();
        this.hasLoadedAll = false;
        this.isLoadingAll = false;
        this._getAllValues$ = this.cache.values$.pipe(operators_1.filter(function () { return !_this.isLoadingAll && _this.hasLoadedAll; }), operators_1.map(function (data) { return data.filter(function (item) { return remote_data_ts_1.isSuccess(item); }); }), operators_1.map(Array_1.array.sequence(remote_data_ts_1.remoteData)), operators_1.distinctUntilChanged(), operators_1.shareReplay(1));
        this.keys$ = this.cache.keys$;
    }
    Object.defineProperty(EntityStore.prototype, "getAllValues$", {
        /**
         * Returns all values of current store.
         * By default returns Observable<RemoteData<L, A[]>>, but can be overwritten by "getAllValues$" setter.
         *
         */
        get: function () {
            return this._getAllValues$;
        },
        /**
         * Overwrites default return-value for "getAllValues$" getter.
         *
         */
        set: function (value) {
            this._getAllValues$ = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Returns entity by a key.
     * If there is no data by a key it triggers "get" argument to receive data and put it in a cache.
     *
     * @param key - Key (name) of an entity you want to receive.
     *
     * @param get - Describes how to receive data if cache by key is empty. Typically it's an API call.
     *
     * @returns - Returns a LiveData stream with requested entity.
     */
    EntityStore.prototype.get = function (key, get) {
        var _this = this;
        var sharedGetter = this.cachedStreams.get(key);
        if (!object_1.isNotNullable(sharedGetter)) {
            var hasValue = this.cache.has(key);
            var cachedValue = this.cache.getValue(key);
            var valueIsResolved = object_1.isNotNullable(cachedValue) && remote_data_ts_1.isSuccess(cachedValue);
            if (hasValue && valueIsResolved) {
                return this.cache.get(key);
            }
            sharedGetter = new rxjs_1.Observable(function (observer) {
                var getterSubscription = get().subscribe(function (value) {
                    _this.cache.set(key, value);
                });
                var cacheSubscription = _this.cache.get(key).subscribe(function (value) {
                    observer.next(value);
                });
                return function () {
                    getterSubscription.unsubscribe();
                    cacheSubscription.unsubscribe();
                    _this.cachedStreams.delete(key);
                };
            }).pipe(operators_1.multicast(new rxjs_1.ReplaySubject(1)), operators_1.refCount());
            this.cachedStreams.set(key, sharedGetter);
        }
        return sharedGetter;
    };
    /**
     * Triggers receiving all entities using "partialGetAll" argument and put them in a cache.
     *
     * @param pk - Means "Primary Key". Describes how to get a key from an entity (required for "updateCache").
     *
     * @param partialGetAll - Describes how to get all values for current entity store. Typically it's an API call.
     *
     * @param predicate - Predicate to filter "partialGetAll" result. E.g. you want to filter invalid entities or you have a business case - use only data created before 01.01.2018.
     *
     * @returns - Returns a LiveData stream with requested entities.
     */
    EntityStore.prototype.getAll = function (pk, partialGetAll, predicate) {
        var _this = this;
        this.isLoadingAll = false;
        return partialGetAll().pipe(tapRD_1.tapRD(function (values) {
            _this.hasLoadedAll = true;
            _this.updateCache(values, pk);
        }), operators_1.switchMap(function (data) { return (remote_data_ts_1.isSuccess(data) ? _this._getAllValues$ : rxjs_1.of(data)); }), operators_1.distinctUntilChanged(), mapRD_1.mapRD(function (entities) {
            if (typeof predicate === 'undefined') {
                return entities;
            }
            var hasChanges = false;
            var filtered = entities.filter(function (value) {
                var result = predicate(value);
                if (!result) {
                    hasChanges = true;
                }
                return result;
            });
            return hasChanges ? filtered : entities;
        }), operators_1.shareReplay(1));
    };
    /**
     * Remove an entity from current entity store.
     *
     * @param key - Key of an entity you want to remove. Using only in optimistic scenario, but required all the time.
     *
     * @param pk - Means "Primary Key". Describes how to get a key from an entity (required for "updateCache").
     *
     * @param remove - Describes how to remove an entity. Typically it's an API call. Should returns an array of existing entities. Exception should be handled inside this stream.
     *
     * @param optimistic - The flag - is optimistic scenario or not, true by default. If true, entity will be removed from a cache before an API call.
     *
     * @returns - Returns a LiveData stream with existing entities.
     */
    EntityStore.prototype.remove = function (key, pk, remove, optimistic) {
        var _this = this;
        if (optimistic === void 0) { optimistic = true; }
        if (optimistic) {
            this.cache.delete(key);
        }
        return remove().pipe(tapRD_1.tapRD(function (values) {
            _this.updateCache(values, pk);
        }), operators_1.switchMap(function () { return _this._getAllValues$; }));
    };
    /**
     * Create an entity
     *
     * @param pk - Means "Primary Key". Describes how to get a key from an entity (required for "updateCache").
     *
     * @param create - Describes how to create an entity. Returns a stream with a created entity.
     *
     * @returns - Returns a LiveData stream with created entity.
     */
    EntityStore.prototype.create = function (pk, create) {
        var _this = this;
        return create().pipe(switchMapRD_1.switchMapRD(function (value) {
            var key = pk(value);
            _this.cache.set(key, remote_data_ts_1.success(value));
            return _this.cache.get(key);
        }));
    };
    /**
     * Update an entity
     *
     * @param key - Key for an entity you want to update.
     *
     * @param update - Describes how to update an entity. Returns a stream with updated entity. Typically it's an API call.
     *
     * @returns - Returns a LiveData stream with updated entity.
     */
    EntityStore.prototype.update = function (key, update) {
        var _this = this;
        return update().pipe(operators_1.tap(function (value) {
            if (remote_data_ts_1.isSuccess(value)) {
                _this.cache.set(key, value);
            }
        }));
    };
    EntityStore.prototype.updateCache = function (values, pk) {
        var entries = values.map(function (item) { return [pk(item), remote_data_ts_1.success(item)]; });
        this.cache.setMany(entries);
    };
    return EntityStore;
}());
exports.EntityStore = EntityStore;
//# sourceMappingURL=entity-store.utils.js.map