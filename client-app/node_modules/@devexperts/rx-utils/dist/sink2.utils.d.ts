import { Observable } from 'rxjs';
import { Monad1 } from 'fp-ts/lib/Monad';
import { Semigroup } from 'fp-ts/lib/Semigroup';
export interface Sink<A> {
    readonly effects: Observable<unknown>;
    readonly value: A;
}
export declare const newSink: <A>(value: A, effects: Observable<unknown>) => Sink<A>;
export declare const URI = "@devexperts/rx-utils//Sink";
export declare type URI = typeof URI;
declare module 'fp-ts/lib/HKT' {
    interface URItoKind<A> {
        [URI]: Sink<A>;
    }
}
export declare const instanceSink: Monad1<URI>;
export declare const sink: {
    sequenceT: <T extends Sink<any>[]>(...t: T & {
        0: Sink<any>;
    }) => Sink<{ [K in keyof T]: [T[K]] extends [Sink<infer A>] ? A : never; }>;
    sequenceArray: <A_1>(ta: Sink<A_1>[]) => Sink<A_1[]>;
    getSemigroup: <A_2>(S: Semigroup<A_2>) => Semigroup<Sink<A_2>>;
    chain: <A_3, B>(f: (a: A_3) => Sink<B>) => (ma: Sink<A_3>) => Sink<B>;
    chainFirst: <A_4, B_1>(f: (a: A_4) => Sink<B_1>) => (ma: Sink<A_4>) => Sink<A_4>;
    flatten: <A_5>(mma: Sink<Sink<A_5>>) => Sink<A_5>;
    ap: <A_6>(fa: Sink<A_6>) => <B_2>(fab: Sink<(a: A_6) => B_2>) => Sink<B_2>;
    apFirst: <B_3>(fb: Sink<B_3>) => <A_7>(fa: Sink<A_7>) => Sink<A_7>;
    apSecond: <B_4>(fb: Sink<B_4>) => <A_8>(fa: Sink<A_8>) => Sink<B_4>;
    map: <A_9, B_5>(f: (a: A_9) => B_5) => (fa: Sink<A_9>) => Sink<B_5>;
    of: <A_10>(a: A_10) => Sink<A_10>;
    URI: "@devexperts/rx-utils//Sink";
};
