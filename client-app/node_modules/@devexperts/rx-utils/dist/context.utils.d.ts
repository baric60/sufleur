import { Sink } from './sink.utils';
import { Monad2 } from 'fp-ts/lib/Monad';
import { Reader } from 'fp-ts/lib/Reader';
export declare const URI = "Context";
export declare type URI = typeof URI;
declare module 'fp-ts/lib/HKT' {
    interface URItoKind2<E, A> {
        Context: Context<E, A>;
    }
}
/**
 * @deprecated Use `Context` from `context2.utils.ts`
 */
export declare class Context<E, A> {
    readonly run: (e: E) => Sink<A>;
    readonly _URI: URI;
    readonly _L: E;
    readonly _A: A;
    constructor(run: (e: E) => Sink<A>);
    map<B>(f: (a: A) => B): Context<E, B>;
    ap<B>(fab: Context<E, (a: A) => B>): Context<E, B>;
    chain<B>(f: (a: A) => Context<E, B>): Context<E, B>;
}
/**
 * @deprecated Use `Context` from `context2.utils.ts`
 */
export declare const asks: <E, A>(f: (e: E) => A) => Context<E, A>;
/**
 * @deprecated Use `Context` from `context2.utils.ts`
 */
export declare const ask: <E>() => Context<E, E>;
/**
 * @deprecated Use `Context` from `context2.utils.ts`
 */
export declare const context: Monad2<URI>;
/**
 * @deprecated
 */
export declare const deferContext: <E extends object, A, K extends keyof E>(fa: Context<E, A>, ...keys: K[]) => Context<Pick<E, Exclude<keyof E, K>>, Context<Pick<E, K>, A>>;
/**
 * @deprecated Use `Context` from `context2.utils.ts`
 */
export declare const sequenceContext: <E, A>(ta: Context<E, A>[]) => Context<E, A[]>;
/**
 * @deprecated Use `Context` from `context2.utils.ts`
 */
export declare const sequenceTContext: <E, T extends Context<E, any>[]>(...t: T & {
    0: Context<E, any>;
}) => Context<E, { [K in keyof T]: [T[K]] extends [Context<E, infer A>] ? A : never; }>;
/**
 * @deprecated Use `Context` from `context2.utils.ts`
 */
export declare const fromReader: <E, A>(r: Reader<E, A>) => Context<E, A>;
/**
 * @deprecated Use `Context` from `context2.utils.ts`
 */
export declare type ContextEnvType<C extends Context<any, any>> = C extends Context<infer E, infer A> ? E : never;
/**
 * @deprecated Use `Context` from `context2.utils.ts`
 */
export declare type ContextValueType<C extends Context<any, any>> = C extends Context<infer E, infer A> ? A : never;
/**
 * @deprecated Use `Context` from `context2.utils.ts`
 */
export interface CombineContext {
    <E, A, R>(a: Context<E, A>, project: (a: A) => R | Sink<R>): Context<E, R>;
    <EA, A, EB, B, R>(a: Context<EA, A>, b: Context<EB, B>, project: (a: A, b: B) => R | Sink<R>): Context<EA & EB, R>;
    <EA, A, EB, B, EC, C, R>(a: Context<EA, A>, b: Context<EB, B>, C: Context<EC, C>, project: (a: A, b: B, c: C) => R | Sink<R>): Context<EA & EB & EC, R>;
    <EA, A, EB, B, EC, C, ED, D, R>(a: Context<EA, A>, b: Context<EB, B>, c: Context<EC, C>, d: Context<ED, D>, project: (a: A, b: B, c: C, d: D) => R | Sink<R>): Context<EA & EB & EC & ED, R>;
    <EA, A, EB, B, EC, C, ED, D, EE, E, R>(a: Context<EA, A>, b: Context<EB, B>, c: Context<EC, C>, d: Context<ED, D>, e: Context<EE, E>, project: (a: A, b: B, c: C, d: D, e: E) => R | Sink<R>): Context<EA & EB & EC & ED & EE, R>;
    <EA, A, EB, B, EC, C, ED, D, EE, E, R>(a: Context<EA, A>, b: Context<EB, B>, c: Context<EC, C>, d: Context<ED, D>, e: Context<EE, E>, project: (a: A, b: B, c: C, d: D, e: E) => R | Sink<R>): Context<EA & EB & EC & ED & EE, R>;
    <EA, A, EB, B, EC, C, ED, D, EE, E, EG, G, R>(a: Context<EA, A>, b: Context<EB, B>, c: Context<EC, C>, d: Context<ED, D>, e: Context<EE, E>, g: Context<EG, G>, project: (a: A, b: B, c: C, d: D, e: E, g: G) => R | Sink<R>): Context<EA & EB & EC & ED & EE & EG, R>;
    <EA, A, EB, B, EC, C, ED, D, EE, E, EG, G, EH, H, R>(a: Context<EA, A>, b: Context<EB, B>, c: Context<EC, C>, d: Context<ED, D>, e: Context<EE, E>, g: Context<EG, G>, h: Context<EH, H>, project: (a: A, b: B, c: C, d: D, e: E, g: G, h: H) => R | Sink<R>): Context<EA & EB & EC & ED & EE & EG & EH, R>;
    <EA, A, EB, B, EC, C, ED, D, EE, E, EG, G, EH, H, EI, I, R>(a: Context<EA, A>, b: Context<EB, B>, c: Context<EC, C>, d: Context<ED, D>, e: Context<EE, E>, g: Context<EG, G>, h: Context<EH, H>, i: Context<EI, I>, project: (a: A, b: B, c: C, d: D, e: E, g: G, h: H, i: I) => R | Sink<R>): Context<EA & EB & EC & ED & EE & EG & EH & EI, R>;
    <EA, A, EB, B, EC, C, ED, D, EE, E, EG, G, EH, H, EI, I, EJ, J, R>(a: Context<EA, A>, b: Context<EB, B>, c: Context<EC, C>, d: Context<ED, D>, e: Context<EE, E>, g: Context<EG, G>, h: Context<EH, H>, i: Context<EI, I>, j: Context<EJ, J>, project: (a: A, b: B, c: C, d: D, e: E, g: G, h: H, i: I, j: J) => R | Sink<R>): Context<EA & EB & EC & ED & EE & EG & EH & EI & EJ, R>;
    <EA, A, EB, B, EC, C, ED, D, EE, E, EG, G, EH, H, EI, I, EJ, J, EK, K, R>(a: Context<EA, A>, b: Context<EB, B>, c: Context<EC, C>, d: Context<ED, D>, e: Context<EE, E>, g: Context<EG, G>, h: Context<EH, H>, i: Context<EI, I>, j: Context<EJ, J>, k: Context<EK, K>, project: (a: A, b: B, c: C, d: D, e: E, g: G, h: H, i: I, j: J, k: K) => R | Sink<R>): Context<EA & EB & EC & ED & EE & EG & EH & EI & EJ & EK, R>;
    <EA, A, EB, B, EC, C, ED, D, EE, E, EG, G, EH, H, EI, I, EJ, J, EK, K, EL, L, R>(a: Context<EA, A>, b: Context<EB, B>, c: Context<EC, C>, d: Context<ED, D>, e: Context<EE, E>, g: Context<EG, G>, h: Context<EH, H>, i: Context<EI, I>, j: Context<EJ, J>, k: Context<EK, K>, l: Context<EL, L>, project: (a: A, b: B, c: C, d: D, e: E, g: G, h: H, i: I, j: J, k: K, l: L) => R | Sink<R>): Context<EA & EB & EC & ED & EE & EG & EH & EI & EJ & EK & EL, R>;
}
/**
 * @deprecated Use `Context` from `context2.utils.ts`
 */
export declare type ProjectMany<A, R> = (...args: A[]) => R;
/**
 * @deprecated Use `Context` from `context2.utils.ts`
 */
export declare const combineContext: CombineContext;
