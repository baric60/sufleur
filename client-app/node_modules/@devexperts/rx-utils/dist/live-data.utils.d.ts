import { Observable } from 'rxjs';
import { RemoteData } from '@devexperts/remote-data-ts';
import { Option } from 'fp-ts/lib/Option';
import { MonadThrow2 } from 'fp-ts/lib/MonadThrow';
import { CoproductLeft } from '@devexperts/utils/dist/typeclasses/product-left-coproduct-left/product-left-coproduct-left.utils';
export interface LiveData<E, A> extends Observable<RemoteData<E, A>> {
}
export declare const URI = "@devexperts/dx-utils//LiveData";
export declare type URI = typeof URI;
declare module 'fp-ts/lib/HKT' {
    interface URItoKind2<E, A> {
        [URI]: LiveData<E, A>;
    }
}
export declare const instanceLiveData: MonadThrow2<URI> & CoproductLeft<URI>;
export declare const liveData: {
    sequenceT: <E, T extends LiveData<E, any>[]>(...t: T & {
        0: LiveData<E, any>;
    }) => LiveData<E, { [K in keyof T]: [T[K]] extends [LiveData<E, infer A>] ? A : never; }>;
    sequenceArray: <E_1, A_1>(ta: LiveData<E_1, A_1>[]) => LiveData<E_1, A_1[]>;
    combine: import("@devexperts/utils/dist/typeclasses/product-left-coproduct-left/product-left-coproduct-left.utils").CoproductMap<"@devexperts/dx-utils//LiveData">;
    chain: <E_2, A_2, B>(f: (a: A_2) => LiveData<E_2, B>) => (ma: LiveData<E_2, A_2>) => LiveData<E_2, B>;
    chainFirst: <E_3, A_3, B_1>(f: (a: A_3) => LiveData<E_3, B_1>) => (ma: LiveData<E_3, A_3>) => LiveData<E_3, A_3>;
    flatten: <E_4, A_4>(mma: LiveData<E_4, LiveData<E_4, A_4>>) => LiveData<E_4, A_4>;
    ap: <E_5, A_5>(fa: LiveData<E_5, A_5>) => <B_2>(fab: LiveData<E_5, (a: A_5) => B_2>) => LiveData<E_5, B_2>;
    apFirst: <E_6, B_3>(fb: LiveData<E_6, B_3>) => <A_6>(fa: LiveData<E_6, A_6>) => LiveData<E_6, A_6>;
    apSecond: <E_7, B_4>(fb: LiveData<E_7, B_4>) => <A_7>(fa: LiveData<E_7, A_7>) => LiveData<E_7, B_4>;
    map: <A_8, B_5>(f: (a: A_8) => B_5) => <E_8>(fa: LiveData<E_8, A_8>) => LiveData<E_8, B_5>;
    fromOption: <E_9>(onNone: () => E_9) => <A_9>(ma: Option<A_9>) => LiveData<E_9, A_9>;
    fromEither: <E_10, A_10>(ma: import("fp-ts/lib/Either").Either<E_10, A_10>) => LiveData<E_10, A_10>;
    fromPredicate: {
        <E_11, A_11, B_6 extends A_11>(refinement: import("fp-ts/lib/function").Refinement<A_11, B_6>, onFalse: (a: A_11) => E_11): (a: A_11) => LiveData<E_11, B_6>;
        <E_12, A_12>(predicate: import("fp-ts/lib/function").Predicate<A_12>, onFalse: (a: A_12) => E_12): (a: A_12) => LiveData<E_12, A_12>;
    };
    filterOrElse: {
        <E_13, A_13, B_7 extends A_13>(refinement: import("fp-ts/lib/function").Refinement<A_13, B_7>, onFalse: (a: A_13) => E_13): (ma: LiveData<E_13, A_13>) => LiveData<E_13, B_7>;
        <E_14, A_14>(predicate: import("fp-ts/lib/function").Predicate<A_14>, onFalse: (a: A_14) => E_14): (ma: LiveData<E_14, A_14>) => LiveData<E_14, A_14>;
    };
    throwError: <E_15, A_15>(e: E_15) => LiveData<E_15, A_15>;
    of: <E_16, A_16>(a: A_16) => LiveData<E_16, A_16>;
    URI: "@devexperts/dx-utils//LiveData";
    coproductLeft: <EA, A_17, EB, B_8>(fa: LiveData<EA, A_17>, fb: LiveData<EB, B_8>) => LiveData<EA | EB, [A_17, B_8]>;
};
export interface LiveDataOption<E, A> extends Observable<RemoteData<E, Option<A>>> {
}
