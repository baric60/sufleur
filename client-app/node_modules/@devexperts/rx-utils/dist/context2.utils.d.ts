import { Monad2 } from 'fp-ts/lib/Monad';
import { Reader } from 'fp-ts/lib/Reader';
import { ProductLeft, ProductMap } from '@devexperts/utils/dist/typeclasses/product-left-coproduct-left/product-left-coproduct-left.utils';
import { Sink } from './sink2.utils';
export declare const URI = "@devexperts/dx-utils//Context";
export declare type URI = typeof URI;
declare module 'fp-ts/lib/HKT' {
    interface URItoKind2<E, A> {
        [URI]: Context<E, A>;
    }
}
export interface Context<E, A> extends Reader<E, Sink<A>> {
}
export declare const instanceContext: Monad2<URI> & ProductLeft<URI>;
export declare const context: {
    sequenceT: <E, T extends Context<E, any>[]>(...t: T & {
        0: Context<E, any>;
    }) => Context<E, { [K in keyof T]: [T[K]] extends [Context<E, infer A>] ? A : never; }>;
    sequenceArray: <E_1, A_1>(ta: Context<E_1, A_1>[]) => Context<E_1, A_1[]>;
    combine: ProductMap<"@devexperts/dx-utils//Context">;
    defer: <E_2 extends object, A_2, K_1 extends keyof E_2>(fa: Context<E_2, A_2>, ...keys: K_1[]) => Context<Pick<E_2, Exclude<keyof E_2, K_1>>, Context<Pick<E_2, K_1>, A_2>>;
    key: <A_3>() => <K_2 extends string | number | symbol>(key: K_2) => Context<Record<K_2, A_3>, A_3>;
    chain: <E_3, A_4, B>(f: (a: A_4) => Context<E_3, B>) => (ma: Context<E_3, A_4>) => Context<E_3, B>;
    chainFirst: <E_4, A_5, B_1>(f: (a: A_5) => Context<E_4, B_1>) => (ma: Context<E_4, A_5>) => Context<E_4, A_5>;
    flatten: <E_5, A_6>(mma: Context<E_5, Context<E_5, A_6>>) => Context<E_5, A_6>;
    ap: <E_6, A_7>(fa: Context<E_6, A_7>) => <B_2>(fab: Context<E_6, (a: A_7) => B_2>) => Context<E_6, B_2>;
    apFirst: <E_7, B_3>(fb: Context<E_7, B_3>) => <A_8>(fa: Context<E_7, A_8>) => Context<E_7, A_8>;
    apSecond: <E_8, B_4>(fb: Context<E_8, B_4>) => <A_9>(fa: Context<E_8, A_9>) => Context<E_8, B_4>;
    map: <A_10, B_5>(f: (a: A_10) => B_5) => <E_9>(fa: Context<E_9, A_10>) => Context<E_9, B_5>;
    of: <E_10, A_11>(a: A_11) => Context<E_10, A_11>;
    URI: "@devexperts/dx-utils//Context";
    productLeft: <EA, A_12, EB, B_6>(fa: Context<EA, A_12>, fb: Context<EB, B_6>) => Context<EA & EB, [A_12, B_6]>;
};
