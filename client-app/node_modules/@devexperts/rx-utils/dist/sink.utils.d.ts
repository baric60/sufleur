import { Observable } from 'rxjs';
import { Monad1 } from 'fp-ts/lib/Monad';
import { Monoid } from 'fp-ts/lib/Monoid';
import { Semigroup } from 'fp-ts/lib/Semigroup';
/**
 * @deprecated Use `Sink` from `sink2.utils.ts`
 */
export declare const URI = "Sink";
/**
 * @deprecated Use `Sink` from `sink2.utils.ts`
 */
export declare type URI = typeof URI;
declare module 'fp-ts/lib/HKT' {
    interface URItoKind<A> {
        Sink: Sink<A>;
    }
}
/**
 * @deprecated Use `Sink` from `sink2.utils.ts`
 */
export declare class Sink<A> {
    readonly value: A;
    readonly sink$: Observable<unknown>;
    readonly _A: A;
    readonly _URI: typeof URI;
    constructor(value: A, sink$?: Observable<unknown>);
    map<B>(f: (a: A) => B): Sink<B>;
    ap<B>(fab: Sink<(a: A) => B>): Sink<B>;
    chain<B>(f: (a: A) => Sink<B>): Sink<B>;
}
/**
 * @deprecated use `sink.getSemigroup` from `sink2.utils.ts`
 */
export declare const getSemigroup: <A>(S: Semigroup<A>) => Semigroup<Sink<A>>;
/**
 * @deprecated use `sink.getMonoid` from `sink2.utils.ts`
 */
export declare const getMonoid: <A>(M: Monoid<A>) => Monoid<Sink<A>>;
/**
 * @deprecated Use `instanceSink` from `sink2.utils.ts`
 */
export declare const sink: Monad1<URI>;
/**
 * @deprecated Use `sink.sequenceT` from `sink2.utils.ts`
 */
export declare const sequenceTSink: <T extends Sink<any>[]>(...t: T & {
    0: Sink<any>;
}) => Sink<{ [K in keyof T]: [T[K]] extends [Sink<infer A>] ? A : never; }>;
