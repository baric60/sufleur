import { either } from 'fp-ts/lib/Either';
import { identity, tuple } from 'fp-ts/lib/function';
import { fromEither, fromNullable, isNone, none, option, some } from 'fp-ts/lib/Option';
import { pipe, pipeable } from 'fp-ts/lib/pipeable';
import { filter, isEmpty } from 'fp-ts/lib/Record';
import { failure, Int, string, success, Type } from 'io-ts';
import { stringify } from 'querystring';
import { parse as parseUrl } from 'url';
/**
 * @since 0.4.0
 */
export class Route {
    constructor(parts, query) {
        this.parts = parts;
        this.query = query;
    }
    /**
     * @since 0.4.0
     */
    static isEmpty(r) {
        return r.parts.length === 0 && isEmpty(r.query);
    }
    /**
     * @since 0.4.0
     */
    static parse(s, decode = true) {
        const route = parseUrl(s, true);
        const oparts = option.map(fromNullable(route.pathname), s => {
            const r = s.split('/').filter(Boolean);
            return decode ? r.map(decodeURIComponent) : r;
        });
        const parts = isNone(oparts) ? [] : oparts.value;
        return new Route(parts, Object.assign({}, route.query));
    }
    /**
     * @since 0.4.0
     */
    toString(encode = true) {
        const nonUndefinedQuery = pipe(this.query, filter(value => value !== undefined));
        const qs = stringify(nonUndefinedQuery);
        const parts = encode ? this.parts.map(encodeURIComponent) : this.parts;
        return '/' + parts.join('/') + (qs ? '?' + qs : '');
    }
}
/**
 * @since 0.4.0
 */
Route.empty = new Route([], {});
const assign = (a) => (b) => Object.assign({}, a, b);
const PARSER_URI = 'fp-ts-routing/Parser';
/**
 * @since 0.4.0
 */
export class Parser {
    constructor(run) {
        this.run = run;
    }
    /**
     * @since 0.4.0
     */
    static of(a) {
        return new Parser(s => some(tuple(a, s)));
    }
    /**
     * @since 0.4.0
     */
    map(f) {
        return this.chain(a => Parser.of(f(a))); // <= derived
    }
    /**
     * @since 0.4.0
     */
    ap(fab) {
        return fab.chain(f => this.map(f)); // <= derived
    }
    /**
     * @since 0.4.0
     */
    chain(f) {
        return new Parser(r => option.chain(this.run(r), ([a, r2]) => f(a).run(r2)));
    }
    /**
     * @since 0.4.0
     */
    alt(that) {
        return new Parser(r => {
            const oar = this.run(r);
            return isNone(oar) ? that.run(r) : oar;
        });
    }
    /**
     * @since 0.4.0
     */
    then(that) {
        return that.ap(this.map(assign));
    }
}
/**
 * @since 0.4.0
 */
export function zero() {
    return new Parser(() => none);
}
/**
 * @since 0.4.0
 */
export function parse(parser, r, a) {
    const oa = option.map(parser.run(r), ([a]) => a);
    return isNone(oa) ? a : oa.value;
}
/**
 * @since 0.5.1
 */
export const getParserMonoid = () => ({
    concat: (x, y) => x.alt(y),
    empty: zero()
});
/**
 * @since 0.5.1
 */
export const parser = {
    URI: PARSER_URI,
    map: (ma, f) => ma.map(f),
    of: Parser.of,
    ap: (mab, ma) => ma.ap(mab),
    chain: (ma, f) => ma.chain(f),
    alt: (fx, f) => new Parser(r => {
        const oar = fx.run(r);
        return isNone(oar) ? f().run(r) : oar;
    }),
    zero
};
const { alt, ap, apFirst, apSecond, chain, chainFirst, flatten, map } = pipeable(parser);
export { 
/**
 * @since 0.5.1
 */
alt, 
/**
 * @since 0.5.1
 */
ap, 
/**
 * @since 0.5.1
 */
apFirst, 
/**
 * @since 0.5.1
 */
apSecond, 
/**
 * @since 0.5.1
 */
chain, 
/**
 * @since 0.5.1
 */
chainFirst, 
/**
 * @since 0.5.1
 */
flatten, 
/**
 * @since 0.5.1
 */
map };
/**
 * @since 0.4.0
 */
export class Formatter {
    constructor(run) {
        this.run = run;
    }
    /**
     * @since 0.4.0
     */
    contramap(f) {
        return new Formatter((r, b) => this.run(r, f(b)));
    }
    /**
     * @since 0.4.0
     */
    then(that) {
        return new Formatter((r, ab) => that.run(this.run(r, ab), ab));
    }
}
/**
 * @since 0.4.0
 */
export function format(formatter, a, encode = true) {
    return formatter.run(Route.empty, a).toString(encode);
}
const FORMATTER_URI = 'fp-ts-routing/Formatter';
/**
 * @since 0.5.1
 */
export const formatter = {
    URI: FORMATTER_URI,
    contramap: (fa, f) => fa.contramap(f)
};
const { contramap } = pipeable(formatter);
export { 
/**
 * @since 0.5.1
 */
contramap };
/**
 * @since 0.4.0
 */
export class Match {
    constructor(parser, formatter) {
        this.parser = parser;
        this.formatter = formatter;
    }
    /**
     * @since 0.4.0
     */
    imap(f, g) {
        return new Match(this.parser.map(f), this.formatter.contramap(g));
    }
    /**
     * @since 0.4.0
     */
    then(that) {
        const p = this.parser.then(that.parser);
        const f = this.formatter.then(that.formatter);
        return new Match(p, f);
    }
}
/**
 * @since 0.5.1
 */
export function imap(f, g) {
    return ma => ma.imap(f, g);
}
/**
 * @since 0.5.1
 */
export function then(mb) {
    return ma => ma.then(mb);
}
const singleton = (k, v) => ({ [k]: v });
/**
 * `succeed` matches everything but consumes nothing
 *
 * @since 0.4.0
 */
export function succeed(a) {
    return new Match(new Parser(r => some(tuple(a, r))), new Formatter(identity));
}
/**
 * `end` matches the end of a route
 * @since 0.4.0
 */
export const end = new Match(new Parser(r => (Route.isEmpty(r) ? some(tuple({}, r)) : none)), new Formatter(identity));
/**
 * `type` matches any io-ts type path component
 *
 * @example
 * import * as t from 'io-ts'
 * import { lit, type, Route } from 'fp-ts-routing'
 * import { some, none } from 'fp-ts/lib/Option'
 *
 * const T = t.keyof({
 *   a: null,
 *   b: null
 * })
 *
 * const match = lit('search').then(type('topic', T))
 *
 * assert.deepStrictEqual(match.parser.run(Route.parse('/search/a')), some([{ topic: 'a' }, Route.empty]))
 * assert.deepStrictEqual(match.parser.run(Route.parse('/search/b')), some([{ topic: 'b' }, Route.empty]))
 * assert.deepStrictEqual(match.parser.run(Route.parse('/search/')), none)
 *
 * @since 0.4.0
 */
export function type(k, type) {
    return new Match(new Parser(r => {
        if (r.parts.length === 0) {
            return none;
        }
        else {
            const head = r.parts[0];
            const tail = r.parts.slice(1);
            return option.map(fromEither(type.decode(head)), a => tuple(singleton(k, a), new Route(tail, r.query)));
        }
    }), new Formatter((r, o) => new Route(r.parts.concat(type.encode(o[k])), r.query)));
}
/**
 * `str` matches any string path component
 *
 * @example
 * import { str, Route } from 'fp-ts-routing'
 * import { some, none } from 'fp-ts/lib/Option'
 *
 * assert.deepStrictEqual(str('id').parser.run(Route.parse('/abc')), some([{ id: 'abc' }, new Route([], {})]))
 * assert.deepStrictEqual(str('id').parser.run(Route.parse('/')), none)
 * @since 0.4.0
 */
export function str(k) {
    return type(k, string);
}
/**
 * @internal
 */
export const IntegerFromString = new Type('IntegerFromString', (u) => Int.is(u), (u, c) => either.chain(string.validate(u, c), s => {
    const n = +s;
    return isNaN(n) || !Number.isInteger(n) ? failure(s, c) : success(n);
}), String);
/**
 * `int` matches any integer path component
 *
 * @example
 * import { int, Route } from 'fp-ts-routing'
 * import { some, none } from 'fp-ts/lib/Option'
 *
 * assert.deepStrictEqual(int('id').parser.run(Route.parse('/1')), some([{ id: 1 }, new Route([], {})]))
 * assert.deepStrictEqual(int('id').parser.run(Route.parse('/a')), none)
 *
 * @since 0.4.0
 */
export function int(k) {
    return type(k, IntegerFromString);
}
/**
 * `lit(x)` will match exactly the path component `x`
 *
 * @example
 * import { lit, Route } from 'fp-ts-routing'
 * import { some, none } from 'fp-ts/lib/Option'
 *
 * assert.deepStrictEqual(lit('subview').parser.run(Route.parse('/subview/')), some([{}, new Route([], {})]))
 * assert.deepStrictEqual(lit('subview').parser.run(Route.parse('/')), none)
 *
 * @since 0.4.0
 */
export function lit(literal) {
    return new Match(new Parser(r => {
        if (r.parts.length === 0) {
            return none;
        }
        else {
            const head = r.parts[0];
            const tail = r.parts.slice(1);
            return head === literal ? some(tuple({}, new Route(tail, r.query))) : none;
        }
    }), new Formatter(r => new Route(r.parts.concat(literal), r.query)));
}
/**
 * Will match a querystring.
 *
 *
 * **Note**. Use `io-ts`'s `strict` instead of `type` otherwise excess properties won't be removed.
 *
 * @example
 * import * as t from 'io-ts'
 * import { lit, str, query, Route } from 'fp-ts-routing'
 *
 * const route = lit('accounts')
 *   .then(str('accountId'))
 *   .then(lit('files'))
 *   .then(query(t.strict({ pathparam: t.string })))
 *   .formatter.run(Route.empty, { accountId: 'testId', pathparam: '123' })
 *   .toString()
 * assert.strictEqual(route, '/accounts/testId/files?pathparam=123')
 *
 *  @since 0.4.0
 */
export function query(type) {
    return new Match(new Parser(r => option.map(fromEither(type.decode(r.query)), query => tuple(query, new Route(r.parts, {})))), new Formatter((r, query) => new Route(r.parts, type.encode(query))));
}
//# sourceMappingURL=index.js.map