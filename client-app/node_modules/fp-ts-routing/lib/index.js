"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Either_1 = require("fp-ts/lib/Either");
var function_1 = require("fp-ts/lib/function");
var Option_1 = require("fp-ts/lib/Option");
var pipeable_1 = require("fp-ts/lib/pipeable");
var Record_1 = require("fp-ts/lib/Record");
var io_ts_1 = require("io-ts");
var querystring_1 = require("querystring");
var url_1 = require("url");
/**
 * @since 0.4.0
 */
var Route = /** @class */ (function () {
    function Route(parts, query) {
        this.parts = parts;
        this.query = query;
    }
    /**
     * @since 0.4.0
     */
    Route.isEmpty = function (r) {
        return r.parts.length === 0 && Record_1.isEmpty(r.query);
    };
    /**
     * @since 0.4.0
     */
    Route.parse = function (s, decode) {
        if (decode === void 0) { decode = true; }
        var route = url_1.parse(s, true);
        var oparts = Option_1.option.map(Option_1.fromNullable(route.pathname), function (s) {
            var r = s.split('/').filter(Boolean);
            return decode ? r.map(decodeURIComponent) : r;
        });
        var parts = Option_1.isNone(oparts) ? [] : oparts.value;
        return new Route(parts, Object.assign({}, route.query));
    };
    /**
     * @since 0.4.0
     */
    Route.prototype.toString = function (encode) {
        if (encode === void 0) { encode = true; }
        var nonUndefinedQuery = pipeable_1.pipe(this.query, Record_1.filter(function (value) { return value !== undefined; }));
        var qs = querystring_1.stringify(nonUndefinedQuery);
        var parts = encode ? this.parts.map(encodeURIComponent) : this.parts;
        return '/' + parts.join('/') + (qs ? '?' + qs : '');
    };
    /**
     * @since 0.4.0
     */
    Route.empty = new Route([], {});
    return Route;
}());
exports.Route = Route;
var assign = function (a) { return function (b) { return Object.assign({}, a, b); }; };
var PARSER_URI = 'fp-ts-routing/Parser';
/**
 * @since 0.4.0
 */
var Parser = /** @class */ (function () {
    function Parser(run) {
        this.run = run;
    }
    /**
     * @since 0.4.0
     */
    Parser.of = function (a) {
        return new Parser(function (s) { return Option_1.some(function_1.tuple(a, s)); });
    };
    /**
     * @since 0.4.0
     */
    Parser.prototype.map = function (f) {
        return this.chain(function (a) { return Parser.of(f(a)); }); // <= derived
    };
    /**
     * @since 0.4.0
     */
    Parser.prototype.ap = function (fab) {
        var _this = this;
        return fab.chain(function (f) { return _this.map(f); }); // <= derived
    };
    /**
     * @since 0.4.0
     */
    Parser.prototype.chain = function (f) {
        var _this = this;
        return new Parser(function (r) { return Option_1.option.chain(_this.run(r), function (_a) {
            var a = _a[0], r2 = _a[1];
            return f(a).run(r2);
        }); });
    };
    /**
     * @since 0.4.0
     */
    Parser.prototype.alt = function (that) {
        var _this = this;
        return new Parser(function (r) {
            var oar = _this.run(r);
            return Option_1.isNone(oar) ? that.run(r) : oar;
        });
    };
    /**
     * @since 0.4.0
     */
    Parser.prototype.then = function (that) {
        return that.ap(this.map(assign));
    };
    return Parser;
}());
exports.Parser = Parser;
/**
 * @since 0.4.0
 */
function zero() {
    return new Parser(function () { return Option_1.none; });
}
exports.zero = zero;
/**
 * @since 0.4.0
 */
function parse(parser, r, a) {
    var oa = Option_1.option.map(parser.run(r), function (_a) {
        var a = _a[0];
        return a;
    });
    return Option_1.isNone(oa) ? a : oa.value;
}
exports.parse = parse;
/**
 * @since 0.5.1
 */
exports.getParserMonoid = function () { return ({
    concat: function (x, y) { return x.alt(y); },
    empty: zero()
}); };
/**
 * @since 0.5.1
 */
exports.parser = {
    URI: PARSER_URI,
    map: function (ma, f) { return ma.map(f); },
    of: Parser.of,
    ap: function (mab, ma) { return ma.ap(mab); },
    chain: function (ma, f) { return ma.chain(f); },
    alt: function (fx, f) {
        return new Parser(function (r) {
            var oar = fx.run(r);
            return Option_1.isNone(oar) ? f().run(r) : oar;
        });
    },
    zero: zero
};
var _a = pipeable_1.pipeable(exports.parser), alt = _a.alt, ap = _a.ap, apFirst = _a.apFirst, apSecond = _a.apSecond, chain = _a.chain, chainFirst = _a.chainFirst, flatten = _a.flatten, map = _a.map;
exports.alt = alt;
exports.ap = ap;
exports.apFirst = apFirst;
exports.apSecond = apSecond;
exports.chain = chain;
exports.chainFirst = chainFirst;
exports.flatten = flatten;
exports.map = map;
/**
 * @since 0.4.0
 */
var Formatter = /** @class */ (function () {
    function Formatter(run) {
        this.run = run;
    }
    /**
     * @since 0.4.0
     */
    Formatter.prototype.contramap = function (f) {
        var _this = this;
        return new Formatter(function (r, b) { return _this.run(r, f(b)); });
    };
    /**
     * @since 0.4.0
     */
    Formatter.prototype.then = function (that) {
        var _this = this;
        return new Formatter(function (r, ab) { return that.run(_this.run(r, ab), ab); });
    };
    return Formatter;
}());
exports.Formatter = Formatter;
/**
 * @since 0.4.0
 */
function format(formatter, a, encode) {
    if (encode === void 0) { encode = true; }
    return formatter.run(Route.empty, a).toString(encode);
}
exports.format = format;
var FORMATTER_URI = 'fp-ts-routing/Formatter';
/**
 * @since 0.5.1
 */
exports.formatter = {
    URI: FORMATTER_URI,
    contramap: function (fa, f) { return fa.contramap(f); }
};
var contramap = pipeable_1.pipeable(exports.formatter).contramap;
exports.contramap = contramap;
/**
 * @since 0.4.0
 */
var Match = /** @class */ (function () {
    function Match(parser, formatter) {
        this.parser = parser;
        this.formatter = formatter;
    }
    /**
     * @since 0.4.0
     */
    Match.prototype.imap = function (f, g) {
        return new Match(this.parser.map(f), this.formatter.contramap(g));
    };
    /**
     * @since 0.4.0
     */
    Match.prototype.then = function (that) {
        var p = this.parser.then(that.parser);
        var f = this.formatter.then(that.formatter);
        return new Match(p, f);
    };
    return Match;
}());
exports.Match = Match;
/**
 * @since 0.5.1
 */
function imap(f, g) {
    return function (ma) { return ma.imap(f, g); };
}
exports.imap = imap;
/**
 * @since 0.5.1
 */
function then(mb) {
    return function (ma) { return ma.then(mb); };
}
exports.then = then;
var singleton = function (k, v) {
    var _a;
    return (_a = {}, _a[k] = v, _a);
};
/**
 * `succeed` matches everything but consumes nothing
 *
 * @since 0.4.0
 */
function succeed(a) {
    return new Match(new Parser(function (r) { return Option_1.some(function_1.tuple(a, r)); }), new Formatter(function_1.identity));
}
exports.succeed = succeed;
/**
 * `end` matches the end of a route
 * @since 0.4.0
 */
exports.end = new Match(new Parser(function (r) { return (Route.isEmpty(r) ? Option_1.some(function_1.tuple({}, r)) : Option_1.none); }), new Formatter(function_1.identity));
/**
 * `type` matches any io-ts type path component
 *
 * @example
 * import * as t from 'io-ts'
 * import { lit, type, Route } from 'fp-ts-routing'
 * import { some, none } from 'fp-ts/lib/Option'
 *
 * const T = t.keyof({
 *   a: null,
 *   b: null
 * })
 *
 * const match = lit('search').then(type('topic', T))
 *
 * assert.deepStrictEqual(match.parser.run(Route.parse('/search/a')), some([{ topic: 'a' }, Route.empty]))
 * assert.deepStrictEqual(match.parser.run(Route.parse('/search/b')), some([{ topic: 'b' }, Route.empty]))
 * assert.deepStrictEqual(match.parser.run(Route.parse('/search/')), none)
 *
 * @since 0.4.0
 */
function type(k, type) {
    return new Match(new Parser(function (r) {
        if (r.parts.length === 0) {
            return Option_1.none;
        }
        else {
            var head = r.parts[0];
            var tail_1 = r.parts.slice(1);
            return Option_1.option.map(Option_1.fromEither(type.decode(head)), function (a) { return function_1.tuple(singleton(k, a), new Route(tail_1, r.query)); });
        }
    }), new Formatter(function (r, o) { return new Route(r.parts.concat(type.encode(o[k])), r.query); }));
}
exports.type = type;
/**
 * `str` matches any string path component
 *
 * @example
 * import { str, Route } from 'fp-ts-routing'
 * import { some, none } from 'fp-ts/lib/Option'
 *
 * assert.deepStrictEqual(str('id').parser.run(Route.parse('/abc')), some([{ id: 'abc' }, new Route([], {})]))
 * assert.deepStrictEqual(str('id').parser.run(Route.parse('/')), none)
 * @since 0.4.0
 */
function str(k) {
    return type(k, io_ts_1.string);
}
exports.str = str;
/**
 * @internal
 */
exports.IntegerFromString = new io_ts_1.Type('IntegerFromString', function (u) { return io_ts_1.Int.is(u); }, function (u, c) {
    return Either_1.either.chain(io_ts_1.string.validate(u, c), function (s) {
        var n = +s;
        return isNaN(n) || !Number.isInteger(n) ? io_ts_1.failure(s, c) : io_ts_1.success(n);
    });
}, String);
/**
 * `int` matches any integer path component
 *
 * @example
 * import { int, Route } from 'fp-ts-routing'
 * import { some, none } from 'fp-ts/lib/Option'
 *
 * assert.deepStrictEqual(int('id').parser.run(Route.parse('/1')), some([{ id: 1 }, new Route([], {})]))
 * assert.deepStrictEqual(int('id').parser.run(Route.parse('/a')), none)
 *
 * @since 0.4.0
 */
function int(k) {
    return type(k, exports.IntegerFromString);
}
exports.int = int;
/**
 * `lit(x)` will match exactly the path component `x`
 *
 * @example
 * import { lit, Route } from 'fp-ts-routing'
 * import { some, none } from 'fp-ts/lib/Option'
 *
 * assert.deepStrictEqual(lit('subview').parser.run(Route.parse('/subview/')), some([{}, new Route([], {})]))
 * assert.deepStrictEqual(lit('subview').parser.run(Route.parse('/')), none)
 *
 * @since 0.4.0
 */
function lit(literal) {
    return new Match(new Parser(function (r) {
        if (r.parts.length === 0) {
            return Option_1.none;
        }
        else {
            var head = r.parts[0];
            var tail = r.parts.slice(1);
            return head === literal ? Option_1.some(function_1.tuple({}, new Route(tail, r.query))) : Option_1.none;
        }
    }), new Formatter(function (r) { return new Route(r.parts.concat(literal), r.query); }));
}
exports.lit = lit;
/**
 * Will match a querystring.
 *
 *
 * **Note**. Use `io-ts`'s `strict` instead of `type` otherwise excess properties won't be removed.
 *
 * @example
 * import * as t from 'io-ts'
 * import { lit, str, query, Route } from 'fp-ts-routing'
 *
 * const route = lit('accounts')
 *   .then(str('accountId'))
 *   .then(lit('files'))
 *   .then(query(t.strict({ pathparam: t.string })))
 *   .formatter.run(Route.empty, { accountId: 'testId', pathparam: '123' })
 *   .toString()
 * assert.strictEqual(route, '/accounts/testId/files?pathparam=123')
 *
 *  @since 0.4.0
 */
function query(type) {
    return new Match(new Parser(function (r) { return Option_1.option.map(Option_1.fromEither(type.decode(r.query)), function (query) { return function_1.tuple(query, new Route(r.parts, {})); }); }), new Formatter(function (r, query) { return new Route(r.parts, type.encode(query)); }));
}
exports.query = query;
//# sourceMappingURL=index.js.map