import { Alternative1 } from 'fp-ts/lib/Alternative';
import { Monad1 } from 'fp-ts/lib/Monad';
import { Monoid } from 'fp-ts/lib/Monoid';
import { Option } from 'fp-ts/lib/Option';
import { Type } from 'io-ts';
import { Contravariant1 } from 'fp-ts/lib/Contravariant';
/**
 * @since 0.4.0
 */
export declare type QueryValues = string | Array<string> | undefined;
/**
 * @since 0.4.0
 */
export interface Query {
    [key: string]: QueryValues;
}
/**
 * @since 0.4.0
 */
export declare class Route {
    readonly parts: Array<string>;
    readonly query: Query;
    /**
     * @since 0.4.0
     */
    static empty: Route;
    constructor(parts: Array<string>, query: Query);
    /**
     * @since 0.4.0
     */
    static isEmpty(r: Route): boolean;
    /**
     * @since 0.4.0
     */
    static parse(s: string, decode?: boolean): Route;
    /**
     * @since 0.4.0
     */
    toString(encode?: boolean): string;
}
/**
 * Encodes the constraint that a given object `O`
 * does not contain specific keys `K`
 *
 * @since 0.4.0
 */
export declare type RowLacks<O, K extends string | number | symbol> = O & Record<Extract<keyof O, K>, never>;
declare module 'fp-ts/lib/HKT' {
    interface URItoKind<A> {
        'fp-ts-routing/Parser': Parser<A>;
    }
}
declare const PARSER_URI = "fp-ts-routing/Parser";
declare type PARSER_URI = typeof PARSER_URI;
/**
 * @since 0.4.0
 */
export declare class Parser<A> {
    readonly run: (r: Route) => Option<[A, Route]>;
    readonly _A: A;
    constructor(run: (r: Route) => Option<[A, Route]>);
    /**
     * @since 0.4.0
     */
    static of<A>(a: A): Parser<A>;
    /**
     * @since 0.4.0
     */
    map<B>(f: (a: A) => B): Parser<B>;
    /**
     * @since 0.4.0
     */
    ap<B>(fab: Parser<(a: A) => B>): Parser<B>;
    /**
     * @since 0.4.0
     */
    chain<B>(f: (a: A) => Parser<B>): Parser<B>;
    /**
     * @since 0.4.0
     */
    alt(that: Parser<A>): Parser<A>;
    /**
     * @since 0.4.0
     */
    then<B>(that: Parser<RowLacks<B, keyof A>>): Parser<A & B>;
}
/**
 * @since 0.4.0
 */
export declare function zero<A>(): Parser<A>;
/**
 * @since 0.4.0
 */
export declare function parse<A>(parser: Parser<A>, r: Route, a: A): A;
/**
 * @since 0.5.1
 */
export declare const getParserMonoid: <A>() => Monoid<Parser<A>>;
/**
 * @since 0.5.1
 */
export declare const parser: Monad1<PARSER_URI> & Alternative1<PARSER_URI>;
declare const alt: <A>(that: () => Parser<A>) => (fa: Parser<A>) => Parser<A>, ap: <A>(fa: Parser<A>) => <B>(fab: Parser<(a: A) => B>) => Parser<B>, apFirst: <B>(fb: Parser<B>) => <A>(fa: Parser<A>) => Parser<A>, apSecond: <B>(fb: Parser<B>) => <A>(fa: Parser<A>) => Parser<B>, chain: <A, B>(f: (a: A) => Parser<B>) => (ma: Parser<A>) => Parser<B>, chainFirst: <A, B>(f: (a: A) => Parser<B>) => (ma: Parser<A>) => Parser<A>, flatten: <A>(mma: Parser<Parser<A>>) => Parser<A>, map: <A, B>(f: (a: A) => B) => (fa: Parser<A>) => Parser<B>;
export { 
/**
 * @since 0.5.1
 */
alt, 
/**
 * @since 0.5.1
 */
ap, 
/**
 * @since 0.5.1
 */
apFirst, 
/**
 * @since 0.5.1
 */
apSecond, 
/**
 * @since 0.5.1
 */
chain, 
/**
 * @since 0.5.1
 */
chainFirst, 
/**
 * @since 0.5.1
 */
flatten, 
/**
 * @since 0.5.1
 */
map };
/**
 * @since 0.4.0
 */
export declare class Formatter<A> {
    readonly run: (r: Route, a: A) => Route;
    readonly _A: A;
    constructor(run: (r: Route, a: A) => Route);
    /**
     * @since 0.4.0
     */
    contramap<B>(f: (b: B) => A): Formatter<B>;
    /**
     * @since 0.4.0
     */
    then<B>(that: Formatter<B> & Formatter<RowLacks<B, keyof A>>): Formatter<A & B>;
}
/**
 * @since 0.4.0
 */
export declare function format<A>(formatter: Formatter<A>, a: A, encode?: boolean): string;
declare module 'fp-ts/lib/HKT' {
    interface URItoKind<A> {
        'fp-ts-routing/Formatter': Formatter<A>;
    }
}
declare const FORMATTER_URI = "fp-ts-routing/Formatter";
declare type FORMATTER_URI = typeof FORMATTER_URI;
/**
 * @since 0.5.1
 */
export declare const formatter: Contravariant1<FORMATTER_URI>;
declare const contramap: <A, B>(f: (b: B) => A) => (fa: Formatter<A>) => Formatter<B>;
export { 
/**
 * @since 0.5.1
 */
contramap };
/**
 * @since 0.4.0
 */
export declare class Match<A> {
    readonly parser: Parser<A>;
    readonly formatter: Formatter<A>;
    readonly _A: A;
    constructor(parser: Parser<A>, formatter: Formatter<A>);
    /**
     * @since 0.4.0
     */
    imap<B>(f: (a: A) => B, g: (b: B) => A): Match<B>;
    /**
     * @since 0.4.0
     */
    then<B>(that: Match<B> & Match<RowLacks<B, keyof A>>): Match<A & B>;
}
/**
 * @since 0.5.1
 */
export declare function imap<A, B>(f: (a: A) => B, g: (b: B) => A): (ma: Match<A>) => Match<B>;
/**
 * @since 0.5.1
 */
export declare function then<B>(mb: Match<B>): <A>(ma: Match<A> & Match<RowLacks<A, keyof B>>) => Match<A & B>;
/**
 * `succeed` matches everything but consumes nothing
 *
 * @since 0.4.0
 */
export declare function succeed<A>(a: A): Match<A>;
/**
 * `end` matches the end of a route
 * @since 0.4.0
 */
export declare const end: Match<{}>;
/**
 * `type` matches any io-ts type path component
 *
 * @example
 * import * as t from 'io-ts'
 * import { lit, type, Route } from 'fp-ts-routing'
 * import { some, none } from 'fp-ts/lib/Option'
 *
 * const T = t.keyof({
 *   a: null,
 *   b: null
 * })
 *
 * const match = lit('search').then(type('topic', T))
 *
 * assert.deepStrictEqual(match.parser.run(Route.parse('/search/a')), some([{ topic: 'a' }, Route.empty]))
 * assert.deepStrictEqual(match.parser.run(Route.parse('/search/b')), some([{ topic: 'b' }, Route.empty]))
 * assert.deepStrictEqual(match.parser.run(Route.parse('/search/')), none)
 *
 * @since 0.4.0
 */
export declare function type<K extends string, A>(k: K, type: Type<A, string>): Match<{
    [_ in K]: A;
}>;
/**
 * `str` matches any string path component
 *
 * @example
 * import { str, Route } from 'fp-ts-routing'
 * import { some, none } from 'fp-ts/lib/Option'
 *
 * assert.deepStrictEqual(str('id').parser.run(Route.parse('/abc')), some([{ id: 'abc' }, new Route([], {})]))
 * assert.deepStrictEqual(str('id').parser.run(Route.parse('/')), none)
 * @since 0.4.0
 */
export declare function str<K extends string>(k: K): Match<{
    [_ in K]: string;
}>;
/**
 * @internal
 */
export declare const IntegerFromString: Type<number, string, unknown>;
/**
 * `int` matches any integer path component
 *
 * @example
 * import { int, Route } from 'fp-ts-routing'
 * import { some, none } from 'fp-ts/lib/Option'
 *
 * assert.deepStrictEqual(int('id').parser.run(Route.parse('/1')), some([{ id: 1 }, new Route([], {})]))
 * assert.deepStrictEqual(int('id').parser.run(Route.parse('/a')), none)
 *
 * @since 0.4.0
 */
export declare function int<K extends string>(k: K): Match<{
    [_ in K]: number;
}>;
/**
 * `lit(x)` will match exactly the path component `x`
 *
 * @example
 * import { lit, Route } from 'fp-ts-routing'
 * import { some, none } from 'fp-ts/lib/Option'
 *
 * assert.deepStrictEqual(lit('subview').parser.run(Route.parse('/subview/')), some([{}, new Route([], {})]))
 * assert.deepStrictEqual(lit('subview').parser.run(Route.parse('/')), none)
 *
 * @since 0.4.0
 */
export declare function lit(literal: string): Match<{}>;
/**
 * Will match a querystring.
 *
 *
 * **Note**. Use `io-ts`'s `strict` instead of `type` otherwise excess properties won't be removed.
 *
 * @example
 * import * as t from 'io-ts'
 * import { lit, str, query, Route } from 'fp-ts-routing'
 *
 * const route = lit('accounts')
 *   .then(str('accountId'))
 *   .then(lit('files'))
 *   .then(query(t.strict({ pathparam: t.string })))
 *   .formatter.run(Route.empty, { accountId: 'testId', pathparam: '123' })
 *   .toString()
 * assert.strictEqual(route, '/accounts/testId/files?pathparam=123')
 *
 *  @since 0.4.0
 */
export declare function query<A, T>(type: Type<A, Record<keyof T, QueryValues>>): Match<A>;
